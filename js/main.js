// ' use strict ' - эта строчка активирует строгий режим синтаксиса Java Script;
                ' use strict ';

// addEventListener - это слушатель событий, который отслеживает событие загрузки( "DOMContentLoaded" ) всего документа( "document" ), после чего начинают работу скрипты Java Script. После того как мы указали какое событие отслеживать, ставим запятую и прописываем стрелочную функцию. В этой функции мы будем прописывать все остальные функции. Это поможет нам не прописывать слушатель события отслеживающий загрузку страицы для каждой функции, а сделает это для всех функций разом .

document.addEventListener('DOMContentLoaded', () => {
    
    // Назначаем переменные получив элементы по "Id".

    // Кнопка "заказчик".
    const customer = document.getElementById('customer');

    // Кнопка "фрилансер".
    const freelancer = document.getElementById('freelancer');

    // Стартовый блок с кнопками "заказчик" и "фрилансер".
    const blockChoice = document.getElementById('block-choice');

    // Кнопка выхода из разделов "заказчик" и "фриланскер". 
    const btnExit = document.getElementById('btn-exit');

    // Блок с разделом "заказчика".
    const blockCustomer = document.getElementById('block-customer');

    // Блок с разделом "фрилансер".
    const blockFreelancer = document.getElementById('block-freelancer');

    // Форма с описанием заказа в разделе "заказчика".
    const formCustomer = document.getElementById('form-customer');

    // Модальное окно для ознакомления с заказом в разделе "фрилансеров".
    const modalOrder = document.getElementById('modal-order');

    // Модальное окно взятого заказа в разделе "фрилансеров".
    const modalOrderActive = document.getElementById('modal-order-active');

    // Массив в который будут записываться свформированные заказы.
    const orders = [];

    // Данные таблицы заказов в разделе "фрилансеров".
    const ordersTable = document.getElementById('orders');



    // Эта функция создаёт таблицу заказов для фрилансеров. Функция обработки заказов "const renderOrders". Вызыватся при нажатии на кнопку "Фрилансер".
    const renderOrders = () => {
        
        // Обнуляет данные таблицы заказов. Не позволяет создать несколько списков заказов одновременно " ordersTable.textContent = '' ". В значении прописываем пустую строку .
        ordersTable.textContent = '';

        // Переборка массива "orders" c помощью цикла "for Each". Для отбора нужен каждый сформированный заказ "order" и его индекс "i".  orders.forEach( ( order, i ) => { });
        // Так как данные таблицы заказов для фрилансиров будут формироваться динамически статическую вёрстку таблицы заказов мы удалим. Данные для таблицы мы будем получать из массива "orders = []", где хранятся все оставленные заказчиками заказы. Чтобы вывести таблицу заказов на страницу применим свойство ".innerHTML" к переменной "ordersTable". Получится ( ordersTable.innerHTML ). Свойство ".innerHTML" - добавит в нашу вёрстку на место где была статическая вёрстка таблицы заказов вёрстку с динамически формирующейся таблицей заказов для фрилансеров. Для этого после "ordersTable.innerHTML" через пробел поставим оператор " += " , который будет добавлять строки с новыми заказами формируя таблицу. Послечего откроем обратные ковычки ` `, и в нутри них вставим одну строку вёрстки из таблицы заказов. Данные таблицы заказов будут обновлятся динамически с помощью инторполяции .
        // Добавим открывающийся тег строки "<tr class="order">" атрибуты "<tr class="order" data-number-order=${i}>". data-number-order=${i} - это номер заказа. В дальнейшем нам это пригодится. С помощью  инторполяции - это символ ${} добавим в первый столбик строки  выражение ${i+1}. Тем самым в столбце с номером заказа будет автоматически формироваться коректный номер заказа, прибавляя к индексу каждого нового заказа единицу. Так как счёт по индексамначинается с ноля, а счёт порядкового номера заказа должен начинаться с единицы. Во втором столбце, чтобы вывести заголовок заказа с помощью знака инторполяции обращаемся через заказ к заголовку заказа. Это записывается так: ${order.title}. В третьем столбце в открывающемся теге <td> добавим class="", так же как и в вёрстке, но в значении класса с помощью инторполяции пропишем: ${order.currency}. Здесь через заказ мы обращаемся к найменованию выбранной валюты для расчёта ( name="currency" ). В четвёртом столбце между открывающимся и закрывающимся тэгами напишим <td> ${order.deadline} </td>. Здесь через заказ мы обращаемся к информации о времени сдачи заказа. Так как теперь информация о заказах формируется динамически закоментируем статическую верстку таблицу от <tbody> до </tbody>.
        // Также, чтобы список заказов формировался корректно,а не появлялось несколько списков заказов необходимо его обнулять. Для этого до цикла ".forEach" необходимо прописать ordersTable.textContent = ''; .    

        // Цикл перебирающий оставленные заказчиками заказы добовляющий их в таблицу.
        orders.forEach( ( order, i ) => {
           
            ordersTable.innerHTML += `
                                        
                <tr class="order" data-number-order=${i}>
                    <td> ${i + 1} </td>
                    <td> ${order.title} </td>
                    <td class="${order.currency}"> </td>
                    <td> ${order.deadline} </td>
                </tr>
 
                `;
        });
        
    };

/////////////////     РАБОТА С ТАБЛИЦЕЙ ЗАКАЗОВ
    // Oбработчик события срабатывающий при клике мыши по таблице заказов. Внутри функции обработчика события создадим переменную "const target" со значением "event.target" - это событие, происходящее на исходном(целевом) элементе. В итоге переменная "const target" - это исходный(целевой) элемет на котором произошло событие. Создадим вторую переменную "const targetOrder" - это заказ по которому мы кликнем. Далее напишим условие для открытия модального окна конкретного заказа. Если " targetOrder " существует  if(targetOrder) , то выполница функция "openModal(targetOrder.dataset.numberOrder);". ОПИШЕМ её ДО ОБРАБОТЧИКА СОБЫТИЯ ordersTable.addEventListener( 'click', ). Функция "const openModal" должна принимать номер заказа "numberOrder". Далее нам нужно получить модальные окна заказов из вёрстки.
    
///////////////     РАБОТА С МОДАЛЬНЫМИ ОКНАМИ КОНКРЕТНОГО ЗАКАЗА.
    // Назначим для этого переменные "const modalOrder"( модальное окно открывающееся после клика на заказ для ознакомления) и "const modalOrderActive"( модальное окно взятого заказа ). Также внутри функции создадим переменную для заказа " const order = [numberOrder] ". Теперь нам нужно узнать активен нашь заказ или нет, для этого получим модальные окна. Создадим переменную "const modal", в значении которой будет прописан тернарный оператор  " order.active ? modalOrderActive: modalOrder; ". В нём "order.active ?" является условием для проверки. Если условие истинно и заказ активный, то в переменную "const modal" вернётся(сохранится) "modalOrderActive", если иначе то вернётся "modalOrder". Таким образом при нажатии на строку заказа откроется корректное модальное окно. Это можно было сделать и с помощью оператора "if else", но это будет длиннее .

     // Функция закрывающая модальные окна(модальные окна взятого или активного заказа). Функция будет принимать стандартное (event), так как мы будет использовать делегирование. Для начала создадим константу "target" - это событие происходящее на исходном(целевом) элементе при клике. Создадим константу "modal", в её значении к "target" применим метод ".closest" закрывающий модальное окно('.order-modal'). Так же для работы функции необходимо открытому модальному окну динамически добавить "id", равный номеру заказа. Далее создадим константу "order" присвоим ей значение равное номеру заказа открытому в модальном окне - "orders[modal.numberOrder]". С помощью оператора "if" Напишем условие при котором будут закрываться модальные окна. Если целевое событие происходит на элементе имеющим класс '.close'(в нашем случае это кнопка с крестиком в верхнем правом углу модального окна), то модальное окно закроется.
     // Также сделаем рабочей кнопку "взять заказ". Для этого с помощью оператора "if" сделаем проверку на то имеет ли кнопка класс 'get-order', используем свойство '.classList'( оно позволяет работать с классами элемента) и его метод '.contains'(проверяет есть ли у элемента нужный класс). В нашем случае  .contains('get-order'). Проверка происходит после клика мыши по кнопке. После чего метод '.contains' при наличии данного класса возвращает 'true' и выполняет код написанный между фигурными скобками (то есть заказ будет взят и свойство заказа order.active станет равно true ) или 'false' - в этом случае код не выполняется.
    const handlerModal = (event) => {
        const target = event.target;
        const modal = target.closest('.order-modal');
        const order = orders[modal.id];

        if ( target.closest('.close') || target === modal ) {
           
            modal.style.display = 'none';
        };

       if (target.classList.contains('get-order')) {

            order.active = true;

       };
        
    };

    // Функция открывающая модальное окно с сформированным заказом.
    const openModal = (numberOrder) => {

        const order = orders[numberOrder];

        // Используем деструктивное присваивание объекта "order". Создадим переменные соответстующие свойствам объекта "order" с помощью деструктивного присваивания. Для этого откроем фигурные скобки, отделим их с обоих сторон пробелами и создадим в нутри них переменные назвав их именами свойств имеющихся у объекта "order". Перечислим их через запятую. После поставим оператор присваивания и укажем откуда мы будем брать данные для этих переменных в нашем случае это объект "order". Также создадим переменную "active = false".

        const { title, firstName, email, phone, description, amount, currency, deadline, active = false } = order;

        const modal = active ? modalOrderActive: modalOrder;

////////////////////////////

       /* Выбор модального окна с помощью оператора "if else". 

        const target = event.target;

            if (order.active) {
                target = modalOrderActive;
            } else {
                target = modalOrder;
            }
        
        */

//////////////////////////

        // Чтобы в дальнейшем добавлять информацию о заказе в модальное окно динамически, с помощью метода .querySelector(), получим элементы модального окна: заголовок модального окна('.modal-title '), имя заказчика('.firstName'), адрес эл.почты заказчика('.email'), описание заказа('.description'), срок сдачи проекта('.deadline'), иконку вида оплаты заказа('.currency_img'), сумму оплаты за заказ('.count'), ссылку на телефон привязанную к кнопке связаться('.phone').

        const titleBlock = modal.querySelector('.modal-title '),
              firstNameBlock = modal.querySelector('.firstName'),
              emailBlock = modal.querySelector('.email'),
              descriptionBlock = modal.querySelector('.description'),
              deadlineBlock = modal.querySelector('.deadline'),
              currencyBlock = modal.querySelector('.currency_img'),
              countBlock = modal.querySelector('.count'),
              phoneBlock = modal.querySelector('.phone');

        // Применим к переменной "titleBlock" свойство ".textContent". Свойство ".textContent" предоставляет доступ к тексту внутри элемента. Так как переменная "titleBlock" это заголовок модального окна, то мы получим текст заголовка, который в свою очередь будет равен значению "order.title".  Значение "order.title" - это заголовок одного из оставленных заказчиком заказов (выбранного для просмотра), который отобразится в заголовоке модального окна с описанием заказа. Все заказы хранятся в массиве "order", поэтому для получения значения какой-либо информации мы обращаемся к "order". Так как мы использовали деструктивное присваивание выше, order уже писать не нужно. 
        titleBlock.textContent = title;

        // Так как переменная "firstNameBlock" это имя заказчика , то мы получим имя заказчика просматриваемого заказа. 
        firstNameBlock.textContent = firstName;

        // Получим адрес эл.почты заказчика, который отобразится в модальном окне заказа. Также добавим в "href" ссылку на email заказчика.
        emailBlock.textContent = email;

        emailBlock.href = 'mailto:' + email; 

        // Получим описание заказа.
        descriptionBlock.textContent = description;

        // Получим срок сдачи заказа.
        deadlineBlock.textContent = deadline;

        // Каждый раз перед присваиванием нового класса. Будем сбрасывать класс элемента на тот который был прописан изначально в вёрстке. Далее с помощью свойства ".classList" и метода ".add" присвоим новый класс элементу находящемуся в переменной "currencyBlock". Тем самым изменим иконку, отображающейся в модальном окне, валюты для оплаты заказа.
        currencyBlock.className = 'currency_img';

        currencyBlock.classList.add(currency);

        // Получим сумму оплаты за заказ.
        countBlock.textContent = amount;

        // Привяжем к кнопке связаться номер телефона оставленный заказчиком при формировании заказа. Изменив значение атрибута ' href = "#" '  на номер телефона оставленный заказчиком. Взяв его из просматриваемого заказа. Так как эти значения используются в обоих модальных окнах, а в модальном окне взятого заказа нет кнопки "связаться" с атрибутом "href" указывающим номер телефона, то произойдёт ошибка. Чтобы этого не произошло необходимо сделать проверку. С помощью тернарного оператора сделаем проверку на то имеится ли номер телефона, если есть, то вывидем номер телефона, если нет - пустую строку .
        phoneBlock ? phoneBlock.href = 'tel:' + phone : '';

        // Добавим элементу "modal"  "id" равный индексу открытого в модальном окне заказа(заказ взят из массива "orders"). Это необходимо для работы функции "handlerModal".
        modal.id = numberOrder;
        
        // После получения модального окна и его данных сделаем его видимым.
        modal.style.display = 'flex';

        // Обработчик событий запускающий функцию "handlerModal", при клике закрывающий модальные окна. Опишим её выше перед функцией открытия модального окна "openModal".
        modal.addEventListener('click', handlerModal );
        
    };

    // Обработчик событий запускающий функцию "openModal" при клике по таблице заказов для фрилансеров (Делегирование).
    ordersTable.addEventListener( 'click', ( event ) => {
        const target = event.target;
        const targetOrder = target.closest('.order');

        if(targetOrder) {

            openModal(targetOrder.dataset.numberOrder);
        };

        
    });

    // Обработчик событий скрывающий блок "blockChoice", делающий видимой форму заказчика и кнопку выход, при нажатии на кнопку заказчик.
    customer.addEventListener('click', () => {
        blockChoice.style.display = 'none' ;
        btnExit.style.display = 'block';
        blockCustomer.style.display = 'block' ;  
    });

    // Обработчик событий скрывающий блок "blockChoice", делающий видимой форму фрилансера и кнопку выход, при нажатии на кнопку фрилансер.
    freelancer.addEventListener('click', () => {
        blockChoice.style.display = 'none' ;
        renderOrders();
        btnExit.style.display = 'block';
        blockFreelancer.style.display = 'block' ;
    });

    // Обработчик событий показывающий блок "blockChoice" и скрывающий блоки "blockCustomer", "blockFreelancer", а так же кнопку "btnExit" при нажатии на кнопку "Выход".
    btnExit.addEventListener('click', () => {
        btnExit.style.display = 'none';
        blockCustomer.style.display = 'none' ; 
        blockFreelancer.style.display = 'none' ;
        blockChoice.style.display = 'block' ;
    });

    // РАБОТА С ИНТЕРФЕЙСОМ ЗАКАЗЧИКА.

    // Форма заказчика находится в переменной 'formCustomer'. Отменим стандартное событие 'submit' в браузере, которое перезагружает страницу при нажатии на кнопку "Оформить заявку". Метод .addEventListener отследит срабатывание события 'submit' в форме заказчика, при нажатии на кнопку "Отправить заявку".Далее выполнится стрелочная функция, которую мы напишем. Чтобы отменить это действие воспользуемся объектом "event"(он формируется во время нажатия на кнопку). У объекта 'event' есть свойство 'defaultPrevented'со значением 'false' ('defaultPrevented: folse'), перезагружаещее страницу. Применим к нему метод ".preventDefault()". Он сделает свойство 'defaultPrevented' истенным ('defaultPrevented: true'). В итоге страница не будет перезагружаться .
    // Создадим переменную "const obj = {}". В неё будут записываться элементы , которые мы перебирём с  помощью цикла "for of". В фигурные скобки записываются значения атрибута "name", от тех элементов которые мы перебрали. 
    // Далее нам нужно получить все элементы формы с id = "form-customer". Она находятся в переменной "formCustomer". Переберём их с помощью цикла "for of". 
    
    
    formCustomer.addEventListener('submit', ( event ) => {
        event.preventDefault();

        const obj = {};

        // Переборка массива с помощью цикла "for of". В цикле "for of" "formCustomer.elements" - это коллекция элементов, а "const elem" - один из элементов, которые мы будем перебирать.Создадим условие 'if', при котором выполнится код. Если " elem.tagName === 'INPUT' "(то есть если имя тега у элемента равно значению'INPUT'), то имя элемента запишится в объект ( const obj = {} ). Поставим символ '&&'( он означает 'И') и допишем, что среди выбранных элементов с тегом 'INPUT' нужно взять те, которые не равны type= "radio". Это записывается так ( elem.type !== 'radio' ). Заключим уже записанные условия в скобки, напишем символ "||"( он означает "ИЛИ"), откроем новые скобки и допишем ещё условия. Нам нужно, чтобы записываемые в объект элементы касающиеся оплаты, соответствовали выбранному способу оплаты. Выберем элементы с типом type= "radio", но не все. Нам нужны лишь выбранные элеметы. Это записывается так( elem.type === 'radio' && elem.checked ). Так же добавим в объект ( const obj = {} ) описание заказа. Теперь нам нужно отобрать элемент с тегом 'TEXTAREA'  Для этого напишем символ "||" откоем новые скобки и напишем новое условие (elem.tagName === 'TEXTAREA').

        // Все отобранные элементы и их значения( obj[elem.name] = elem.value ) будут сохранятся в переменную ( const obj = {} ). Для этого перед циклом "for of" создадим переменную ( const obj = {} ), изначально она будет пуста,поэтому после оператора присваивания ставим фигурные скобки.

        // Так же нам нужно очистить элементы форм после отправки. Для этого в конце цикла допишем условие if (elem.type !== 'radio') { elem.value = ''; }

        // Все наши заказы в дальнейшем будут сохраняться в один массив. Создадим для них переменную const orders = []. Так как переменная будет изначальна пуста, её значением будут квадратные скобки. Напишем её рядом с остальными переменными. После того как нашь заказ ( const obj = {} ) будет создан, с помощью метода ( .push ) добавим его в массив ( const orders = [] ) в котором хранятся все наши заказы. Это записывается так ( orders.push(obj); ).

        // formCustomer.reset(); Очистит информацию в полях ввода в форме заказчика. Вернув изначальные значения.

        for (const elem of formCustomer.elements) {

            if ((elem.tagName === 'INPUT' && elem.type !== 'radio') || (elem.type === 'radio' && elem.checked) || (elem.tagName === 'TEXTAREA')) {

               obj[elem.name] = elem.value;
            }
               
                if (elem.type !== 'radio') {

                    elem.value = '';
                }
            
        }; 

            formCustomer.reset();

            orders.push(obj); 

       /*  /////////////////////////////////////////

       // Переборка массива с помощью цикла ".for Each". Чтобы перебрать колекцию элементов  "formCustomer.elements" с помощью метода ".for Each" нужно поместить их в массив. Для этого используем новый оператор "..." называется spread (распростанение, расширение) или rest (остаток) в зависимости от того, где и как он используется. Оператор "...", используемый перед объектом, или любой другой коллекцией элементов(строками, массивом), называет spread. С помощью него мы можем получить список элементов находящихся в коллекции. Далее мы можем с ним работать с помощью метода .forEach(). Для этого открываем квадратные скобки, используем spread оператор "...", после чего пишем название коллекции, где находятся элементы. Пишется это так: [...formCustomer.elements].forEach(); Пропишем стрелочную функцию в нутри скобок метода .forEach( () => {} ). Она примит три значения и бует запускаться столько раз сколько элементов в масиве. Здесь строчка " [ ...formCustomer.elements ].forEach( (elem) => " заменет нам строчку " for (const elem of formCustomer.elements) " из цикла "for of". Функция отбора элементов аналогична функции в цикле "for of". Записываем значение каждого элемента в  const obj. Так же нам нужно очистить элементы форм после отправки. Для этого в конце цикла допишем условие if (elem.type !== 'radio') { elem.value = ''; }

        [ ...formCustomer.elements ].forEach( (elem) => {

          
            if ((elem.tagName === 'INPUT' && elem.type !== 'radio') || (elem.type === 'radio' && elem.checked) || (elem.tagName === 'TEXTAREA')) {

                obj[elem.name] = elem.value;
            }

                if (elem.type !== 'radio') {

                    elem.value = '';
                }

        });

            orders.push(obj);

        ////////////////////////////////////////////

        // Переборка массива с помощью метода "filter". Необходимо создать переменную "const elements" в которую мы поместим массив ( [...formCustomer.elements] ) и отфильтруем его с помощью метода " .filter() " прописав в нём все условия отбора элементов прописываимые и в превидущих способах. Далее перебираем каждый отфильтрованный элемент в массиве с помощью цикла ".for Each" и записываем его значение в  const obj. Так же нам нужно очистить элементы форм после отправки. Для этого в конце цикла допишем условие if (elem.type !== 'radio') { elem.value = ''; }   

        const elements = [...formCustomer.elements].filter( (elem) => {

            return (elem.tagName === 'INPUT' && elem.type !== 'radio') || (elem.type === 'radio' && elem.checked) || (elem.tagName === 'TEXTAREA');
        } );

            elements.forEach( (elem) => {

                obj[elem.name] = elem.value;

                
                if (elem.type !== 'radio') {

                    elem.value = '';
                }

            });

            orders.push(obj);

        ////////////////////////////////////////// */  

    });


    // РАБОТА С ИНТЕРФЕЙСОМ ФРИЛАНСЕРА.

    // Создадим рядом со всеми переменными переменную const ordersTable пместим в неё таблицу заказов получив её по "id".
    // С помощью метода .innerHTML добавим в нашу верстку с таблицей строку с заказом. Для этого  возьмём переменную 'ordersTable' и применим к ней метод '.innerHTML' ( ordersTable.innerHTML ), после оператора присваивания откроем обратные ковычки и напишем вёрстку с новой строкой состоящей из четырёх колонок. Теперь с помощью ${} мы можем добавлять в нашу таблицу переменные. 
    // Но так как мы в последствии будем добавлять множество заказов, то нам нужно использовать не оператор присваивания "=", а оператор "+=", который будет складывать строки в таблице одну за одной.
    // Теперь в строке <tr> с вёрской таблицы добавим class="order", также как и в статической вёрстке. Дальше данные в таблицу мы будем добавлять динамически.
    // Для этого до обработчиков событий создадим функцию обработки заказов "const renderOrders", присвоим ей стрелочную функцию и вставим туда вёрстку строки с четырьмя колонами. Эта функция будет вызываться при нажатии на кнопку "Фрилансер".
    // Так же добавим функцию " renderOrders(); " в обработчик события блока Фрилансер ( freelancer.addEventListener ) после скрытия блока ( blockChoice.style.display = 'none' ).
    // В нутри функции обработки заказов "const renderOrders" переберём массив "orders" c помощью цикла "for Each". Вставим вёрстку с таблицей внутрь цикла.
    // Создадим обработчик события срабатывающий при клике мыши по таблице заказов ordersTable.addEventListener( 'click', ).
    
});